<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>無限井字過三關 (3子限制版)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #2c3e50;
            color: white;
            margin: 0;
        }

        h1 { margin-bottom: 10px; }
        
        .status {
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-template-rows: repeat(3, 100px);
            gap: 10px;
            background-color: #34495e;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        .cell {
            background-color: #ecf0f1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            color: #2c3e50;
            transition: all 0.3s ease;
            user-select: none;
        }

        .cell:hover {
            background-color: #bdc3c7;
        }

        /* 玩家顏色 */
        .cell.x { color: #e74c3c; }
        .cell.o { color: #3498db; }

        /* 即將消失的棋子樣式 (半透明) */
        .fading {
            opacity: 0.3;
            transform: scale(0.9);
            border: 2px dashed #7f8c8d;
            background-color: #fab1a0; /* 輕微紅色背景警示 */
        }

        /* 贏家樣式 */
        .winning {
            background-color: #2ecc71 !important;
            color: white !important;
        }

        button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 1rem;
            background-color: #e67e22;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        button:hover { background-color: #d35400; }

        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            color: #bdc3c7;
            max-width: 300px;
            text-align: center;
        }
    </style>
</head>
<body>

    <h1>無限井字過三關</h1>
    <div class="status" id="status">輪到玩家: X</div>
    
    <div class="board" id="board">
        <div class="cell" data-index="0"></div>
        <div class="cell" data-index="1"></div>
        <div class="cell" data-index="2"></div>
        <div class="cell" data-index="3"></div>
        <div class="cell" data-index="4"></div>
        <div class="cell" data-index="5"></div>
        <div class="cell" data-index="6"></div>
        <div class="cell" data-index="7"></div>
        <div class="cell" data-index="8"></div>
    </div>

    <button onclick="resetGame()">重新開始</button>
    <div class="info">規則：每人最多放 3 粒棋。當你要放第 4 粒時，你最早放的那粒會消失 (半透明提示)。</div>

    <script>
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const cells = document.querySelectorAll('.cell');
        
        let currentPlayer = 'X';
        let gameActive = true;
        
        // 記錄每位玩家的棋子位置 (使用 Queue 隊列概念)
        // 數組存儲的是格子的索引 (0-8)
        let xMoves = [];
        let oMoves = [];

        // 勝利組合
        const winningConditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // 橫向
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // 縱向
            [0, 4, 8], [2, 4, 6]             // 斜向
        ];

        function handleCellClick(clickedCellEvent) {
            const clickedCell = clickedCellEvent.target;
            const clickedCellIndex = parseInt(clickedCell.getAttribute('data-index'));

            // 1. 檢查遊戲是否進行中
            if (!gameActive) return;

            // 2. 檢查該格子是否已經有棋子 (這是一個簡化版，不允許直接點擊自己即將消失的棋子來"刷新"它，必須點空位)
            if (clickedCell.classList.contains('x') || clickedCell.classList.contains('o')) {
                return;
            }

            // 執行下棋邏輯
            makeMove(clickedCellIndex);
        }

        function makeMove(index) {
            let currentMoves = currentPlayer === 'X' ? xMoves : oMoves;

            // 如果已經有 3 步，需要移除最早的一步
            if (currentMoves.length === 3) {
                const indexToRemove = currentMoves.shift(); // 移除數組第一個元素 (最早的步)
                const cellToRemove = cells[indexToRemove];
                
                // 清除該格子的樣式
                cellToRemove.classList.remove(currentPlayer.toLowerCase());
                cellToRemove.classList.remove('fading'); // 移除半透明效果
                cellToRemove.innerText = '';
            }

            // 加入新的一步
            currentMoves.push(index);
            const cellToAdd = cells[index];
            cellToAdd.classList.add(currentPlayer.toLowerCase());
            cellToAdd.innerText = currentPlayer;

            // 檢查是否勝利
            checkResult();
        }

        function checkResult() {
            let currentMoves = currentPlayer === 'X' ? xMoves : oMoves;
            let roundWon = false;

            // 只有當棋子達到 3 顆時才有可能贏
            if (currentMoves.length === 3) {
                for (let i = 0; i < winningConditions.length; i++) {
                    const [a, b, c] = winningConditions[i];
                    // 檢查當前玩家的棋子是否包含這三個位置
                    if (currentMoves.includes(a) && currentMoves.includes(b) && currentMoves.includes(c)) {
                        roundWon = true;
                        // 高亮勝利棋子
                        cells[a].classList.add('winning');
                        cells[b].classList.add('winning');
                        cells[c].classList.add('winning');
                        break;
                    }
                }
            }

            if (roundWon) {
                statusElement.innerText = `玩家 ${currentPlayer} 獲勝！`;
                gameActive = false;
                return;
            }

            // 切換玩家
            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
            updateStatusAndVisuals();
        }

        function updateStatusAndVisuals() {
            statusElement.innerText = `輪到玩家: ${currentPlayer}`;

            // 清除所有格子的 "fading" 狀態
            cells.forEach(cell => cell.classList.remove('fading'));

            // 檢查當前玩家是否已經有 3 步棋
            // 如果有，將他最早下的那一步 (數組索引 0) 標記為 fading
            let currentMoves = currentPlayer === 'X' ? xMoves : oMoves;
            
            if (currentMoves.length === 3) {
                const fadingIndex = currentMoves[0]; // 最舊的一步
                const fadingCell = cells[fadingIndex];
                fadingCell.classList.add('fading');
                statusElement.innerText += " (下一步將移除舊棋)";
            }
        }

        function resetGame() {
            currentPlayer = 'X';
            gameActive = true;
            xMoves = [];
            oMoves = [];
            statusElement.innerText = "輪到玩家: X";
            
            cells.forEach(cell => {
                cell.classList.remove('x', 'o', 'winning', 'fading');
                cell.innerText = '';
            });
        }

        // 初始化監聽器
        cells.forEach(cell => cell.addEventListener('click', handleCellClick));
    </script>
</body>
</html>
